---
title: "Gains and losses in rheumatoid arthritis data from inferCNV"
author: "Alexandra Tidd"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    fig_width: 8
    keep_md: true
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    theme: lumen
params:
  sce: NULL
  cell_group_name: NULL
  infercnv_dir: NULL
  cache_dir: NULL
  rerun: true
---

```{r setup, include = F, message = F, warning = F, class.source = 'fold-hide'}
# wd <- ifelse(Sys.info()['nodename'] == "mib119104s", '~/Volumes/', '') |> paste0('/lustre/scratch125/casm/team268im/at31/RA_som_mut/infercnv/') ; setwd(wd)
# rmarkdown::render('reports/infercnv.Rmd', output_file = 'driver_coverage.html', output_dir = 'reports/', params = list(rerun = T))

# libraries
library(magrittr)
library(ggplot2)
library(gridExtra)
library(Matrix)
library(SummarizedExperiment)
library(SingleCellExperiment)
library(glmGamPoi)

# dev.off() if there is a device
dev_off_if <- function() {if (length(dev.list()) != 0) { dev.off() }}

# chunk options
knitr::opts_knit$set(root.dir = '../')
knitr::opts_chunk$set(
  warning = FALSE, 
  dpi = 300, 
  message = FALSE,
  cache.path = params$cache_dir) 
```

# Loading the inferCNV outputs

inferCNV was run on the scRNA-seq data to call copy number variants in synovial cells. No reference group was used, so the average profile of all cells was used in each patient as the baseline. 

First, we load the CITE-seq object. We convert it to a SingleCellExperiment object. Then we add the CNV metadata from the inferCNV run to the object.

```{r load_sce, results = 'asis'}
# load gene coords
coords <-
  readr::read_tsv('data/hg38_gencode_v27.txt', col_names = c('name', 'chr', 'start', 'stop'))

# load CTAP and metadata
ctap <-
  readr::read_tsv('data/Zhang2023/syn26710600/CTAP_donor_mapping.tsv') %>%
  dplyr::select(sample = donor, CTAP)
md <- 
  readr::read_tsv('data/Zhang2023/syn26710600/SYNAPSE_METADATA_MANIFEST.tsv') %>%
  dplyr::distinct()

# load sce, add inferCNV 
sce <- xfun::cache_rds({
  
  # load sce
  sce <- readRDS(params$sce)
  
  # get cnv metadata
  cnvs <- 
    list.files(
      params$infercnv_dir,
      pattern = 'map_metadata_from_infercnv.txt',
      recursive = T) %>%
    purrr::set_names(., dirname(.)) %>%
    purrr::map(function(file) {
      file.path(params$infercnv_dir, file) %>% 
        read.table(sep = '\t')
      }) %>%
    dplyr::bind_rows() %>%
    dplyr::mutate(infercnv = T)
  
  # left join cnvs to coldata, reorder, restore rownames
  col_data <- merge(sce@colData, cnvs, by = 'row.names', all.x = T, sort = F)
  rownames(col_data) <- col_data[, 1]
  col_data <- 
    col_data[colnames(sce), -1] %>%
    DataFrame()
  
  # add to sce
  sce@colData <- col_data
  
  # return
  sce

}, file = 'sce.rds', rerun = params$rerun)

# remove NA's for inferCNV analysis
sce <- sce[, !is.na(sce$proportion_cnv_chr1)]
 
 # assign cell group
sce@colData$cell_group <-
  sce@colData[, params$cell_group_name]
```

## `map_metadata_from_infercnv.txt`

The `inferCNV` output file `map_metadata_from_infercnv.txt` contains columns with different CNV measures at whole-chromosome level per cell, with rownames denoting cells. The columns have the following values...

```{r echo = F, results = 'asis'}
tibble::tribble(
  ~name, ~`type - value`,
  '`has_*`', 'binary - whether any CNV / loss / duplication is found within the given chr',
  '`proportion_*`', 'proportion - proportion of genes that are part of any CNV / loss / duplication within the given chr',
  '`proportion_scaled_*`', 'proportion - same as proportion_*, but taking into account whether genes that are duplicated / lost are a single copy or two copies, as a weight',
  '`top_loss_*`', 'the top CNVs that affect the most genes'
) %>%
  knitr::kable()
```

## HMM regional predictions

We also load the CNV regions prediced by HMM. According to [their wiki](https://github.com/broadinstitute/infercnv/wiki/infercnv-i6-HMM-type#infercnv-i6-hmm)...

As well as aneuploidy, we want to look for smaller recurrent structural changes, including focal-/arm-level events. 

> The inferCNV i6 HMM is a six-state CNV model that predicts the following CNV levels:
>
> * State 1: 0x: complete loss
> * State 2: 0.5x: loss of one copy
> * State 3: 1x: neutral
> * State 4: 1.5x: addition of one copy
> * State 5: 2x: addition of two copies
> * State 6: 3x: essentially a placeholder for >2x copies but modeled as 3x.

```{r get_hmm}
cnv_regions <- xfun::cache_rds({
  
  # get HMM predictions
  cnv_regions <- 
    list.files(
      params$infercnv_dir,
      pattern = 'HMM_CNV_predictions.HMMi6.leiden.hmm_mode-subclusters.Pnorm_0.5.pred_cnv_regions.dat',
      recursive = T) %>%
    purrr::set_names(., dirname(.)) %>%
    purrr::map(function(file) {
      file.path(params$infercnv_dir, file) %>% 
        readr::read_tsv(show_col_types = F)
      }) %>%
    dplyr::bind_rows(.id = 'sample') %>%
    # refactor chromosomes
    dplyr::mutate(
      chr = chr %>% {forcats::fct_reorder(., gsub('chr', '', .) %>% as.numeric())},
      direction = dplyr::case_when(
        state < 3 ~ 'loss',
        state > 3 ~ 'dupli',
        TRUE ~ 'neutral'),
      ploidy = dplyr::case_when(
        state == 1 ~ '0x',
        state == 2 ~ '0.5x',
        state == 3 ~ '1x',
        state == 4 ~ '1.5x',
        state == 5 ~ '2x',
        state == 6 ~ '>2x',
        TRUE ~ NA
        ) %>% forcats::fct_reorder(state),
      region = gsub('.*region_', '', cnv_name) %>% as.numeric(),
      cell_group = cell_group_name %>% gsub('\\..*', '', .))
  
  # calculate region midpoints for plotting
  cnv_regions$midpoint <-
    (cnv_regions$start + cnv_regions$end) / 2
  
  # return
  cnv_regions
  
}, file = 'cnv_regions.rds', rerun = params$rerun)
```

```{r plot_cnv_regions_pred, fig.height = 20, fig.width = 10}
cnv_regions %>%
  ggplot(aes(x = midpoint, fill = ploidy, group = ploidy)) +
  geom_density(data = cnv_regions %>% dplyr::filter(direction == 'dupli'),
               aes(y = ..density..), 
               position = position_stack(), 
               colour = NA) +
  geom_density(data = cnv_regions %>% dplyr::filter(direction == 'loss'),
               aes(y = -..density..), 
               position = position_stack(reverse = T), 
               colour = NA) +
  ggh4x::facet_grid2(chr ~ cell_group, scales = 'free', independent = 'x') +
  theme_bw() +
  theme(axis.text.x = element_blank()) +
  scale_fill_manual(
    values = c('0x' = '#00008B', '0.5x' = '#b4b0ff', '1' = 'white', 
               '1.5x' = '#ffc2c2', '2x' = '#d64242', '>2x' = '#8B0000')) 
```

## UMAPs

First, we plot UMAPs by cell grouping.

```{r plot_umaps}
dittoSeq::dittoDimPlot(sce, params$cell_group_name, size = 0.2) +
  coord_fixed()
```

Then, we visualise gains and loss proportions for each chromosome on the UMAP. The `Nebulosa` package is used to show the values as densities.

```{r plot_chr_gains, fig.width = 10, fig.height = 4, results = 'hide'}
paste0('chr', 1:22) %>% 
  purrr::map(function(chr) {
    events <-
      paste('proportion', c('dupli', 'loss'), chr, sep = '_')
    sce %>%
      Nebulosa::plot_density(events, size = 0.5) %>%
      print()
    reducedDim(sce, 'UMAP_uwot') %>%
      cbind(sce@colData[, events]) %>%
      tibble::as_tibble() %>%
      tidyr::pivot_longer(3:4) %>%
      dplyr::arrange(value) %>%
      ggplot(aes(x = UMAP1, y = UMAP2, colour = value)) + 
      geom_point(size = 0.1) +
      coord_fixed() +
      theme_classic() +
      scale_color_viridis_c() +
      facet_grid(~ name) %>%
      print()
  })
```

## Heatmaps

Now, we will plot gain and loss proportions by chromosome.

First, we plot single cell-level CNVs by direction and by celltype.

```{r plot_gains_and_losses_by_ct, results = 'hide'}
# at single-cell level
sce@colData[, params$cell_group_name] %>%
  unique() %>%
  purrr::map(function(cgn) {
    c('dupli', 'loss') %>%
      purrr::map(function(direction) {
        p_dat <-
          sce@colData[sce@colData[, params$cell_group_name] == cgn, ]
        if (nrow(p_dat) > 0) {
          p_mat <-
            p_dat[, grepl(paste0('proportion_', direction), colnames(p_dat))]
          p_annot <- 
            p_dat[, c('sample'), drop = F] %>%
            as.data.frame()
          pheatmap::pheatmap(
            p_mat, 
            show_rownames = F, 
            annotation_row = p_annot,
            # hclust error: size cannot be NA nor exceed 65536
            cluster_rows = ((nrow(p_mat) < 65536) == T),
            legend = F,
            main = paste0(params$cell_group_name, ': ', cgn, '\ndirection: ', direction)) %>%
            print()
        }
      })
  })
```

We also plot sample-x-celltype level events (mean-summarised). 

```{r plot_gains_and_losses_by_id, fig.width = 12}
# mean proportion loss / gain per chromosome per celltype per id
p_dat <-
  sce@colData %>%
  tibble::as_tibble() %>%
  dplyr::mutate(cell_group = get(params$cell_group_name)) %>%
  dplyr::group_by(sample, cell_group) %>%
  dplyr::summarise(
    dplyr::across(dplyr::starts_with('proportion_'), ~ mean(.x, na.rm = T))) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(sample_x_cg = paste0(sample, '_', cell_group)) %>%
  tibble::column_to_rownames('sample_x_cg') 

# split gain and loss
c('dupli', 'loss') %>% 
  purrr::map(function(direction) {
    p_mat <-
      p_dat[, grepl(paste0('proportion_', direction), colnames(p_dat))]
    p_annot <- 
      p_dat[, c('sample', 'cell_group')] %>%
      as.data.frame()
    pheatmap::pheatmap(
      p_mat, 
      show_rownames = F, 
      annotation_row = p_annot,
      main = paste0('direction: ', direction)) %>%
      print()
  })
```

## chr7 gain

We are most interested in the chr7 gain events in fibroblasts. We visualise their distribution across the dataset. 

```{r chr7_prop_dist}
# prep data
p_dat <-
  sce@colData %>%
  tibble::as_tibble() %>%
  dplyr::group_by(sample) %>%
  dplyr::mutate(cell_group = get(params$cell_group_name),
                n_cells = dplyr::n())

# define functions
plot_prop_chr7_gain <- function(p_dat, title) {
  plot_func <- function(p_dat, position_arg) {
    p_dat %>%
      ggplot() +
      geom_bar(aes(x = cell_group, 
                   fill = proportion_dupli_chr7, 
                   group = proportion_dupli_chr7),
               position = position_arg) +
      scale_x_discrete(guide = guide_axis(angle = -45)) +
      theme_classic() +
      scale_fill_viridis_b(n.breaks = 9, limits = c(0, 1)) 
  }
  
  # plot both count (stack) and proportion (fill), annotate n cells
  list(
    plot_func(p_dat, position_fill(reverse = T)) +
      ggtitle(title) +
      theme(axis.text.x = element_blank(),
            axis.title.x = element_blank()) +
      ylab('count'),
    plot_func(p_dat, position_stack(reverse = T)) +
      ylab('proportion')) %>%
    patchwork::wrap_plots(ncol = 1) 
}

# plot, across all and by patient
plot_prop_chr7_gain(p_dat, 'chr7 gain - all cells')
p_dat %>%
  {split(., .$sample)} %>%
  purrr::walk2(names(.), ., function(id, df) {
    df %>%
    plot_prop_chr7_gain(
      paste0('chr7 gains - ', id, ' (', unique(df$n_cells), ' cells)')) %>%
      print()
  })
```

# Pseudobulking and DGEA

We pseudobulk chr7+ cells and perform differential expression analysis. In order to do this, we use the `glmGamPoi` package in R. This analysis follows a [tutorial](https://bioconductor.org/packages/devel/bioc/vignettes/glmGamPoi/inst/doc/pseudobulk.html) and the [glmGamPoi GitHub](https://github.com/const-ae/glmGamPoi).

We will define chr7+ cells as those with >80% of genes affected by duplication and chr7 WT cells as those with <20% of genes affected. We will pseudobulk by patient, cell group, and chr7 ploidy to produce a reduced object.

```{r chr7_gain, class.source = 'fold-show'}
sce$chr7_gain <-
  ifelse(sce$proportion_dupli_chr7 > 0.8, 1, 
         ifelse(sce$proportion_dupli_chr7 < 0.2, 0, 
                NA))
```

```{r chr7_gain_prop, result = 'asis'}
dat <-
  tibble::tibble(chr7_gain_value = sce$chr7_gain,
               cell_group = sce$cell_group) %>%
  dplyr::mutate(
    chr7_gain_status = dplyr::case_when(
      is.na(chr7_gain_value) ~ 'unknown/intermediate',
      chr7_gain_value == 0 ~ 'WT',
      chr7_gain_value == 1 ~ 'gain')
  ) 

cat('Counts and proportions of chr7 gain, all cells')
dat %>%
  dplyr::mutate(n_cells = dplyr::n()) %>%
  dplyr::group_by(chr7_gain_status, n_cells) %>%
  dplyr::summarise(n = dplyr::n(),
                   `%` = 100 * dplyr::n() / unique(n_cells)) %>%
  knitr::kable()

cat('Counts and proportions of chr7 gain, by cell group')
dat %>%
  dplyr::group_by(cell_group) %>%
  dplyr::mutate(n_cells = dplyr::n()) %>%
  dplyr::group_by(cell_group, chr7_gain_status, n_cells) %>%
  dplyr::summarise(n = dplyr::n(),
                   `%` = 100 * dplyr::n() / unique(n_cells)) %>%
  knitr::kable()
```

```{r pseudobulk_chr7_gain, class.source = 'fold-show'}
reduced_sce <- xfun::cache_rds({
  
  # pseudobulk the sce object by patient, cell group and chr7 ploidy
  # (exclude intermediate chr7 values)
  reduced_sce <-
    glmGamPoi::pseudobulk(
      sce[, !is.na(sce$sample) & 
            !is.na(sce$chr7_gain) &
            !is.na(sce$cell_group)], 
      group_by = vars(sample, cell_group, chr7_gain)
    )
  
  # return
  reduced_sce
  
}, file = 'reduced_sce.rds', rerun = params$rerun)
```

With the reduced data, we can conduct differential expression analysis, treating the data like bulk RNA-seq data. 

We will identify which genes in stromal cells are changed most by chr7 gain. We do this by fitting one GLM model for each gene, with the chr7 status, cell group and patient as factors.

```{r deseq, message = T}
# fit one GLM model for each gene
fit <- xfun::cache_rds({
  fit <-
    glmGamPoi::glm_gp(
      reduced_sce,
      design = ~ chr7_gain + sample + cell_group,
      verbose = T
    )
  fit
}, file = 'fit.rds', rerun = params$rerun)

# show model output
summary(fit)
```

Next, we test for differential gene expression.

```{r test_ge}
# minimum accepted adj_pval
min_p <- 0.05

# get differential expression
de_res <- xfun::cache_rds({
  
  # test differences
  de_res <-
    glmGamPoi::test_de(
      fit, 
      contrast = 
        cond(chr7_gain = 1) -
        cond(chr7_gain = 0)
    )
  
  # define significant up/downregulation and position
  de_res <-
    de_res %>% 
    tibble::as_tibble() %>%
    dplyr::mutate(
      direction = dplyr::case_when(
        lfc < -1.5 & adj_pval < min_p ~ 'downregulated',
        lfc > 1.5 & adj_pval < min_p ~ 'upregulated',
        TRUE ~ NA)) %>%
    dplyr::left_join(coords)
  
  de_res
}, file = 'de_res.rds', rerun = params$rerun)
```

```{r plot_de}
# plot
de_res %>%
  ggplot(aes(x = lfc, y = -log10(adj_pval), colour = direction, 
             size = chr == 'chr7', shape = chr == 'chr7')) +
  geom_point() +
  geom_hline(yintercept = -log10(min_p), linetype = 'dashed') +
  geom_vline(xintercept = c(log2(1.5), log2(2)), linetype = 'dashed', colour = 'purple') +
  geom_vline(xintercept = c(-1.5, 1.5), linetype = 'dashed') +
  ggrepel::geom_text_repel(
    data = 
      de_res %>% 
      dplyr::filter(!is.na(direction)) %>%
      dplyr::group_by(direction) %>%
      dplyr::filter(rank(adj_pval) <= 10 | rank(lfc, ties.method = 'min') <= 10),
    aes(label = name, ),
    min.segment.length = 0, nudge_x = 0.7, show.legend = F) +
  theme_classic() +
  scale_colour_manual(values = c('upregulated' = 'darkred',
                                 'downregulated' = 'darkblue'), 
                      na.value = 'darkgrey') +
  scale_size_manual(values = c('TRUE' = 3, 'FALSE' = 2), na.value = 2) +
  scale_shape_manual(values = c('TRUE' = 55, 'FALSE' = 16), na.value = 16)
```

These are the most strongly upregulated genes:

```{r get_downreg_degs}
de_res %>%
  tibble::as_tibble() %>% 
  dplyr::filter(adj_pval < 0.01) %>%
  dplyr::arrange(-lfc, adj_pval) %>%
  head(10) %>%
  knitr::kable()
```

These are the most strongly downregulated genes:

```{r get_upreg_degs}
de_res %>%
  tibble::as_tibble() %>% 
  dplyr::filter(adj_pval < 0.01) %>%
  dplyr::arrange(lfc, adj_pval) %>%
  head(10) %>%
  knitr::kable()
```
